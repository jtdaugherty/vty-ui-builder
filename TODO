
vBox/hBox

  * Support child spacing controls (applies to all generated boxes
    within any vBox / hBox)

  * Support child size policy controls, e.g.,

    <!-- Percentage of top-level box size -->
    <vBox sizing="50%,25%,25%">
      <ch1>...</ch1>
      <ch2>...</ch2>
      <ch3>...</ch3>
    </vBox>

    <!-- Fixed number of rows/columns -->
    <vBox sizing="25,auto,13">
      <ch1>...</ch1>
      <ch2>...</ch2>
      <ch3>...</ch3>
    </vBox>

Add support for:

  * List

    - User needs to specify internal value and widget types for the
      list (annoying)

    - Specifying initial list contents could get ugly, since we can't
      necessarily type-check the values resulting from the child
      elements of a <list>.

  * Table
  * Radio buttons
  * Limits
  * Fixed
  * Group

- think about ways to make it possible for users to include arbitrary
  widgets in the generated interfaces.  an example use case is one in
  which the widget to be included is generated by some other means or
  has no XML/builder support.  another example is a widget which must
  be generated by some third party code.

  the user may need to encode the type of the generated widget in the
  XML so that the generated source will type-check.  Maybe something
  like:

  <custom type="SomeType" func="mkWidget"/>

  where mkWidget :: IO ()

  This may also necessitate support for custom imports to make names
  like 'mkWidget' available to the generated source in module form,
  e.g.,

  <import name="Some.Module.Name"/>

  (and a corresponding --import option for vty-ui-builder's config)

  A more extreme kind of this feature would be one where the function
  to construct the widget (i.e., 'mkWidget') could be located by the
  builder and its type introspected.  As long as the type was 'Widget
  a' for some 'a', it would be compatible with the builder.  (This
  sidesteps the issue of a constructor which builds a concrete widget
  type (e.g., Dialog) which has a projection to extract the
  underlyling widget value.)

  Another option for this is to create a new widget type called a
  "slot" which delegates all focus/keyboard events to a child, except
  the child's type is hidden by an existential type and can be set at
  runtime.  This is ugly in some ways but makes this whole problem
  basically go away because it means that widgets of arbitrary type
  can be generated at a later time.  It won't work in the case where
  the thing someone wants to put in the slot is a composite widget
  (e.g., a dialog) where it has its own focus group, so that is
  annoying.

- make it impossible to reference focus group entry names which are
  not in the interface corresponding to a focus group (unless they are
  refs in 'common', in which case that is okay!)

- figure out how to resolve whitespace handling in fText and attr
  elements so it is clear what the semantics will be

- figure out why DTD validation isn't catching some of the attribute
  mistakes I've seen (#REQUIRED attributes are missing and the
  validator does not complain).  HaXml bug?

  Yep, HaXml bug.  Patch submitted.  Turns out multiple attribute
  lists weren't being merged as per the spec, and only the last one
  declared took precedence.  And the last one declared has no required
  attributes, since it's the auto-generated one (all #IMPLIED).
  Whoops!

- support setting render context information: skin, default attributes

- improve error reporting and reduce number of pathological error
  cases by performing up-front validation and by using more types (too
  many 'error' calls)

- make vty-ui-builder support loading extra DTDs?

- think about ways to unify the API for specifying element source
  generation handlers and validators

- add support for multiple DTD paths

- the API for specifying which structural/widget names and handlers
  should be used for the DTD generation, validation, and source code
  generation is pretty awful.

- implement support for whole-document validation in addition to just
  per-element validation (specific use cases?)
